#include <step_select.h>

void hal_application_code(void);

#if(STEP_SELECT > 0)
#include "hal_data.h"
ssp_err_t ssp_err;
#endif

#if(STEP_SELECT > 1)
volatile bool g_gpt0_flag = 0;  /* software flag set by the gpt callback */
#endif

#if(STEP_SELECT > 2)
#define TRNG_NUMBERS_TO_READ    1
uint32_t g_trng_result;   /* storage for the trng */
#endif

#if(STEP_SELECT > 3)
uint16_t adc_results[4];
#endif


void hal_application_code(void)
{
    #if(STEP_SELECT > 0)
    /*
     * Open GPT0 - Used to set the software flag g_gpt0_flag in the g_gpt0 callback function
     */
    /*** ENTER API CALL HERE TO OPEN THE GPT ***/
    g_gpt0.p_api->open(g_gpt0.p_ctrl, g_gpt0.p_cfg);


    if(SSP_SUCCESS != ssp_err)
    {
        __BKPT(0);   /* If open is unsuccessful, hit breakpoint */
    }

    /*
     * Open DAC - Output value is a scaled value generated by the TRNG
     */
    /*** ENTER API CALL HERE TO OPEN THE DAC ***/
    g_dac0.p_api->open(g_dac0.p_ctrl, g_dac0.p_cfg);

    if(SSP_SUCCESS != ssp_err)
    {
        __BKPT(0);   /* If open is unsuccessful, hit breakpoint */
    }

    /*
     * Open the SCE - Required prior to opening the TRNG
     */
    /*** ENTER API CALL HERE TO OPEN THE SCE ***/
    g_sce.p_api->open(g_sce.p_ctrl, g_sce.p_cfg);

    if(SSP_SUCCESS != ssp_err)
    {
        __BKPT(0);   /* If open is unsuccessful, hit breakpoint */
    }

    /*
     * Open the TRNG - Used to generate a random number for the DAC to output
     */
    /*** ENTER API CALL HERE TO OPEN THE TRNG ***/
    g_sce_trng.p_api->open(g_sce_trng.p_ctrl, g_sce_trng.p_cfg);

    if(SSP_SUCCESS != ssp_err)
    {
        __BKPT(0);   /* If open is unsuccessful, hit breakpoint */
    }
    #endif


    #if (STEP_SELECT > 3)
    /*
     * Open ADC - Input value will be stored in the array adc_results[]
     */
    ssp_err = g_adc0.p_api->open(g_adc0.p_ctrl, g_adc0.p_cfg);
    if(SSP_SUCCESS != ssp_err)
    {
        __BKPT(0);   /* If open is unsuccessful, hit breakpoint */
    }

    /*
     * Configure the ADC
     */
    ssp_err = g_adc0.p_api->scanCfg(g_adc0.p_ctrl, g_adc0.p_channel_cfg);
    if(SSP_SUCCESS != ssp_err)
    {
        __BKPT(0);   /* If open is unsuccessful, hit breakpoint */
    }

    /*
     * Open DTC Transfer Driver
     * Prior to doing this, set the Source & Destination addresses
     */
    g_transfer0.p_cfg->p_info->p_dest = &adc_results[0];
    g_transfer0.p_cfg->p_info->p_src = (void*)&R_S12ADC0->ADDRn[0];

    ssp_err = g_transfer0.p_api->open(g_transfer0.p_ctrl, g_transfer0.p_cfg);
    if(SSP_SUCCESS != ssp_err)
    {
        __BKPT(0);   /* If open is unsuccessful, hit breakpoint */
    }

    /*
     * Open GPT1 - Used to trigger the ADC
     * The trigger will be made via the ELC - Event Link Controller
     */
    ssp_err = g_gpt1.p_api->open(g_gpt1.p_ctrl, g_gpt1.p_cfg);
    if(SSP_SUCCESS != ssp_err)
    {
        __BKPT(0);   /* If open is unsuccessful, hit breakpoint */
    }


    /*
     * Link the GPT1 to ADC
     */
    /*** ENTER API CALL HERE TO LINK THE ADC AND GPT OVERFLOW EVENT ***/

    if(SSP_SUCCESS != ssp_err)
    {
        __BKPT(0);   /* If open is unsuccessful, hit breakpoint */
    }

    /*
     * Start the ADC running.
     * This will be triggered by the GTP1 overflow event
     * This will occur when the GPT1 is started
     */
    ssp_err = g_adc0.p_api->scanStart(g_adc0.p_ctrl);
    if(SSP_SUCCESS != ssp_err)
    {
        __BKPT(0);   /* If open is unsuccessful, hit breakpoint */
    }
    #endif

    #if (STEP_SELECT > 2)
    /* Start the GPT0 running.  This will set a software flag once a second.
     * When this flag is set, a random number will be read, scaled and set
     * as the DAC output value
     */
    /*** ENTER API CALL HERE TO START THE GPT0 RUNNING ***/

    if(SSP_SUCCESS != ssp_err)
    {
        __BKPT(0);   /* If start is unsuccessful, hit breakpoint */
    }
    #endif

    #if (STEP_SELECT > 3)
    /* Start the GPT1 running.  This will generate an GPT Overflow Event every
     * 250ms which will trigger the ADC scan. The ADC scan end interrupt will
     * be taken by the DTC and will transfer the ADC results to the array adc_results[].
     */
    ssp_err = g_gpt1.p_api->start(g_gpt1.p_ctrl);
    if(SSP_SUCCESS != ssp_err)
    {
        __BKPT(0);   /* If start is unsuccessful, hit breakpoint */
    }

    #endif

    while(1)
    {
        #if (STEP_SELECT > 2)
        /* Wait for the g_gpt0_flag to be set.
         * This will be set in the g_gpt0 callback function that will be called
         * every second
         */
        while(0 == g_gpt0_flag);

        /* Read a random number from the TRNG */
        /*** ENTER API CALL HERE TO READ THE TRNG ***/

        if(SSP_SUCCESS != ssp_err)
        {
            __BKPT(0);
        }

        /* Scale the 32 bit number for the 12-bit DAC */
        g_trng_result = g_trng_result/0x100000;

        /* Write the value to the DAC */
        /*** ENTER API CALL HERE TO WRITE TO THE DAC ***/

        if(SSP_SUCCESS != ssp_err)
        {
            __BKPT(0);
        }

        /* Reset the flag so that operation waits */
        g_gpt0_flag = 0;
        #endif
    }
}


#if (STEP_SELECT > 1)
void cb_gpt0(timer_callback_args_t * p_args)
{
    SSP_PARAMETER_NOT_USED(p_args);

    /* Set a software flag to indicate that the interrupt has occurred */
    g_gpt0_flag = 1;
}
#endif
